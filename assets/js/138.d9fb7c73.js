(window.webpackJsonp=window.webpackJsonp||[]).push([[138],{441:function(t,e,r){"use strict";r.r(e);var l=r(23),v=Object(l.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"内置组件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内置组件"}},[t._v("#")]),t._v(" 内置组件")]),t._v(" "),r("p",[t._v("本文说明 router-view 和 router-link 内置组件，只要知道，这两个内容，本质上是组件，其他的就好理解了。")]),t._v(" "),r("ul",[r("li",[t._v("router-link")])]),t._v(" "),r("p",[t._v("假设需要手写一个同样功能的组件，那么自然就好理解了。就是一个标签，支持通过某个事件触发路由跳转，而这个路由跳转在内部是通过 "),r("code",[t._v("push")]),t._v(" 和 "),r("code",[t._v("replace")]),t._v(" 实现的。")]),t._v(" "),r("ul",[r("li",[t._v("router-view")])]),t._v(" "),r("p",[t._v("先想想这个组件的功能，不管怎么特殊，它是一个组件这个根本的，它的功能就是根据不同的路由，在同一个位置切换不同的页面内容，那么显然这里是跟 matcher 有关的，内部就是根据当前的路由，调用 根据 match 去做匹配，找到对应的组件，将组件渲染到这个位置。")])])}),[],!1,null,null,null);e.default=v.exports}}]);