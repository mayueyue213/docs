(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{494:function(_,v,e){"use strict";e.r(v);var t=e(23),i=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"tcp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[_._v("#")]),_._v(" TCP")]),_._v(" "),e("p",[_._v("TCP 是面向连接的、可靠的、基于字节流的传输层通信协议，本文主要关键连接和断开连接等内容。")]),_._v(" "),e("h2",{attrs:{id:"报文格式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#报文格式"}},[_._v("#")]),_._v(" 报文格式")]),_._v(" "),e("p",[e("mg",{attrs:{src:"/images/networking/tcp.jpg",alt:"TCP报文格式"}})],1),_._v(" "),e("ul",[e("li",[_._v("端口号：TCP之上是应用程序，端口号就是应用程序的标识，发送时多路复用应用数据，接收时多路分解送达上层应用程序。")]),_._v(" "),e("li",[_._v("序号和确认号：用于数据的顺序识别，提供可靠性保证。")]),_._v(" "),e("li",[_._v("6 bits 标志字段：可理解为 TCP 的分类。")]),_._v(" "),e("li",[_._v("窗口字段：用于流量控制。")])]),_._v(" "),e("h2",{attrs:{id:"三次握手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[_._v("#")]),_._v(" 三次握手")]),_._v(" "),e("p",[_._v("三次握手大家都知道，但很多人却只是记住了这个名词而已。理解三次握手，关注的是")]),_._v(" "),e("ul",[e("li",[_._v("序列号(Sequence Number)")]),_._v(" "),e("li",[_._v("确认号(Acknowledgement Number)")]),_._v(" "),e("li",[_._v("标志位 SYN，FIN， RST，ACK")])]),_._v(" "),e("p",[_._v("三次握手的流程图如下\n"),e("mg",{attrs:{src:"/images/networking/handshake.jpg",alt:"TCP报文格式"}}),_._v("\n三次握手的过程，一定要在理解的基础上去记忆，不要想着拍个快照存入脑中")],1),_._v(" "),e("ul",[e("li",[_._v("SYN(Synchronize Sequence Number): 表示这是个同步报文，只是负责接头，负责双方同步，建立联系。")]),_._v(" "),e("li",[_._v("client_isn/server_isn: 这个就是报文头部中序号(Sequence Number)字段，ISN是个非常关键的内容，目前暂时知道这是个随机数即可。")]),_._v(" "),e("li",[_._v("ACK: 这个就是报文头部中的确认号(Acknowledgement Number)字段。")])]),_._v(" "),e("p",[_._v("TCP是基于字节流的传输，每个字节都是一个编号，而双方交换的 seq，就是这个编号的起始值，是字节流的起始编号。假设 client_isn 为 2333，server_isn 为 6666，那么")]),_._v(" "),e("ul",[e("li",[_._v("第一次握手：我的初始编号是 2333")]),_._v(" "),e("li",[_._v("第二次握手：我的初始编号是 6666，你的ISN 2333 我收到了，你下一次给我 2334")]),_._v(" "),e("li",[_._v("第三次握手：你的ISN 6666 我也收到了，这是我的起始编号 2334 的数据，你下次给我 6667 为开始编号的数据")])]),_._v(" "),e("p",[e("strong",[_._v("三次握手的本质是双方同步初始化序列号(ISN，Initial Sequence Number)")]),_._v("，基于 ISN 对后续传输的字节进行编号。")]),_._v(" "),e("h2",{attrs:{id:"状态图"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#状态图"}},[_._v("#")]),_._v(" 状态图")]),_._v(" "),e("p",[_._v("为了维护双方的连接，需要维护一个状态机，建立连接过程中相关的状态变化如下\n"),e("mg",{attrs:{src:"/images/networking/handshake-status-1.jpg",alt:"TCP 连接状态变化图"}})],1),_._v(" "),e("ol",[e("li",[_._v("服务端处于监听状态")]),_._v(" "),e("li",[_._v("客户端发出 SYN 请求同步之后，客户端变为 SYN_SENT")]),_._v(" "),e("li",[_._v("服务端收到 SYN 请求之后，给客户端响应，变为 SYN_RCVD")]),_._v(" "),e("li",[_._v("客户端收到 SYN 响应之后，给服务端发出确认应答，变为 ESTABLISHE")]),_._v(" "),e("li",[_._v("客户端收到确认后，变为 ESTABLISHE")]),_._v(" "),e("li",[_._v("双方都是 ESTABLISHE 之后就可以进行正式通信了")])]),_._v(" "),e("p",[_._v("相对于连接来说，断开的过程不那么容易理解\n"),e("mg",{attrs:{src:"/images/networking/tcp-close.jpg",alt:"TCP 断开连接状态变化图"}}),_._v("\n假设左侧是 A，右侧是 B。为什么 A 会有 "),e("code",[_._v("FIN_WAIT_1")]),_._v("和"),e("code",[_._v("FIN_WAIT_2")]),_._v("的区别，B 要发送两次 ACK 消息，而不是合并呢？")],1),_._v(" "),e("ol",[e("li",[_._v("A 给 B 发送 FIN：我没有数据要给你了，你也准备准备断开吧")]),_._v(" "),e("li",[_._v("B 给 A 发送 ACK 响应 FIN 通知：我知道你不会再发数据了，我正在收尾")]),_._v(" "),e("li",[_._v("B 给 A 发送 FIN：我也没东西要给你了")]),_._v(" "),e("li",[_._v("A 给 B 发 ACK：好的，那就再见了！")])]),_._v(" "),e("p",[e("strong",[_._v("不要认为步骤2和步骤3是连续的，中间还可能有其他操作")]),_._v("。TCP 是全双工通信有关，FIN_WAIT_1 和 FIN_WAIT_2，都表示在等待一个 FIN 响应，在步骤 2 和 步骤 3 之间，B 可能还是会给 A 发消息。\nA 不能直接跑路，只能一步一步来，不然 B 的部分数据可能就丢了，所以要在保留接收能力的情况下，启动关闭流程。")]),_._v(" "),e("p",[_._v("在 B 发送 FIN 之后，B 进入到 LAST_ACK 状态，表示期待收到一个确认，而 A 收到后，会发送一个确认，进入 TIME_WAIT(2 MSL，Maximum Segment Lifetime，报文最大生存时间) 状态。B 在期待一个 ACK，如果没有收到它会重发，因而 A 等待 2MSL 的时间，最后没再收到 B 的结束通知，就关闭了。")])])}),[],!1,null,null,null);v.default=i.exports}}]);