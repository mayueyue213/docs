<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>知识概要</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" type="image/png" sizes="32x32" href="/docs/images/mayueyue-32.png">
    <meta name="description" content="前端框架学习笔记">
    <meta name="keywords" content="前端框架学习笔记">
    
    <link rel="preload" href="/docs/assets/css/0.styles.e658a316.css" as="style"><link rel="preload" href="/docs/assets/js/app.7952ff67.js" as="script"><link rel="preload" href="/docs/assets/js/3.2c08a1e7.js" as="script"><link rel="preload" href="/docs/assets/js/56.9d9e990d.js" as="script"><link rel="preload" href="/docs/assets/js/10.8d48b436.js" as="script"><link rel="preload" href="/docs/assets/js/6.164b8275.js" as="script"><link rel="preload" href="/docs/assets/js/4.981889e3.js" as="script"><link rel="preload" href="/docs/assets/js/24.5bfcb19a.js" as="script"><link rel="preload" href="/docs/assets/js/14.b16e20b9.js" as="script"><link rel="preload" href="/docs/assets/js/7.21f341ae.js" as="script"><link rel="preload" href="/docs/assets/js/18.9fb89893.js" as="script"><link rel="preload" href="/docs/assets/js/23.60844ae4.js" as="script"><link rel="prefetch" href="/docs/assets/js/100.1602b0da.js"><link rel="prefetch" href="/docs/assets/js/101.c3797752.js"><link rel="prefetch" href="/docs/assets/js/102.ed6c463f.js"><link rel="prefetch" href="/docs/assets/js/103.159b3936.js"><link rel="prefetch" href="/docs/assets/js/104.9c56980a.js"><link rel="prefetch" href="/docs/assets/js/105.139fc413.js"><link rel="prefetch" href="/docs/assets/js/106.317b002a.js"><link rel="prefetch" href="/docs/assets/js/107.d6a48820.js"><link rel="prefetch" href="/docs/assets/js/108.71f125c5.js"><link rel="prefetch" href="/docs/assets/js/109.af20f644.js"><link rel="prefetch" href="/docs/assets/js/11.21afe38c.js"><link rel="prefetch" href="/docs/assets/js/110.dadddaa1.js"><link rel="prefetch" href="/docs/assets/js/111.5f7604f5.js"><link rel="prefetch" href="/docs/assets/js/112.eda7bc2a.js"><link rel="prefetch" href="/docs/assets/js/113.4414a8a9.js"><link rel="prefetch" href="/docs/assets/js/114.447f2418.js"><link rel="prefetch" href="/docs/assets/js/115.363c02d0.js"><link rel="prefetch" href="/docs/assets/js/116.b3c6d01b.js"><link rel="prefetch" href="/docs/assets/js/117.9fb2e5d8.js"><link rel="prefetch" href="/docs/assets/js/118.dab165c2.js"><link rel="prefetch" href="/docs/assets/js/119.f7d7e0fe.js"><link rel="prefetch" href="/docs/assets/js/12.13f5c72b.js"><link rel="prefetch" href="/docs/assets/js/120.ffcf8b6c.js"><link rel="prefetch" href="/docs/assets/js/121.227e74e8.js"><link rel="prefetch" href="/docs/assets/js/122.ddfad576.js"><link rel="prefetch" href="/docs/assets/js/123.b30b55a0.js"><link rel="prefetch" href="/docs/assets/js/124.bce508b6.js"><link rel="prefetch" href="/docs/assets/js/125.317ced0f.js"><link rel="prefetch" href="/docs/assets/js/126.d0f02b38.js"><link rel="prefetch" href="/docs/assets/js/127.150e581a.js"><link rel="prefetch" href="/docs/assets/js/128.59763692.js"><link rel="prefetch" href="/docs/assets/js/129.4f1b1448.js"><link rel="prefetch" href="/docs/assets/js/13.6456f4f1.js"><link rel="prefetch" href="/docs/assets/js/130.25f9146f.js"><link rel="prefetch" href="/docs/assets/js/131.b0dbb98f.js"><link rel="prefetch" href="/docs/assets/js/132.9780a231.js"><link rel="prefetch" href="/docs/assets/js/133.3eed3eeb.js"><link rel="prefetch" href="/docs/assets/js/134.d40cd789.js"><link rel="prefetch" href="/docs/assets/js/135.b0d68517.js"><link rel="prefetch" href="/docs/assets/js/136.8310e5c0.js"><link rel="prefetch" href="/docs/assets/js/137.b764dc68.js"><link rel="prefetch" href="/docs/assets/js/138.d9fb7c73.js"><link rel="prefetch" href="/docs/assets/js/139.773e6e78.js"><link rel="prefetch" href="/docs/assets/js/140.b6d1b35e.js"><link rel="prefetch" href="/docs/assets/js/141.06d26f81.js"><link rel="prefetch" href="/docs/assets/js/142.73c5f3e0.js"><link rel="prefetch" href="/docs/assets/js/143.6f747e24.js"><link rel="prefetch" href="/docs/assets/js/144.0a4b8e26.js"><link rel="prefetch" href="/docs/assets/js/145.c3320afb.js"><link rel="prefetch" href="/docs/assets/js/146.0cd89fc2.js"><link rel="prefetch" href="/docs/assets/js/147.4d6400fc.js"><link rel="prefetch" href="/docs/assets/js/148.7740bfc2.js"><link rel="prefetch" href="/docs/assets/js/149.a3230a5d.js"><link rel="prefetch" href="/docs/assets/js/15.6278d184.js"><link rel="prefetch" href="/docs/assets/js/150.2081e4fb.js"><link rel="prefetch" href="/docs/assets/js/16.a7ded4f1.js"><link rel="prefetch" href="/docs/assets/js/17.5f1b14de.js"><link rel="prefetch" href="/docs/assets/js/19.e1463f50.js"><link rel="prefetch" href="/docs/assets/js/20.13eca4d4.js"><link rel="prefetch" href="/docs/assets/js/21.011555e9.js"><link rel="prefetch" href="/docs/assets/js/22.5e6a0578.js"><link rel="prefetch" href="/docs/assets/js/25.ce7c13d8.js"><link rel="prefetch" href="/docs/assets/js/26.2a034de1.js"><link rel="prefetch" href="/docs/assets/js/27.e5137c98.js"><link rel="prefetch" href="/docs/assets/js/28.45928969.js"><link rel="prefetch" href="/docs/assets/js/29.d3af5461.js"><link rel="prefetch" href="/docs/assets/js/30.b69d72e3.js"><link rel="prefetch" href="/docs/assets/js/31.8b2ee0a0.js"><link rel="prefetch" href="/docs/assets/js/32.9674f7dc.js"><link rel="prefetch" href="/docs/assets/js/33.9354631a.js"><link rel="prefetch" href="/docs/assets/js/34.af2bdb81.js"><link rel="prefetch" href="/docs/assets/js/35.cc264763.js"><link rel="prefetch" href="/docs/assets/js/36.5f15ea8b.js"><link rel="prefetch" href="/docs/assets/js/37.aac312ab.js"><link rel="prefetch" href="/docs/assets/js/38.cb18f7f7.js"><link rel="prefetch" href="/docs/assets/js/39.06b585ec.js"><link rel="prefetch" href="/docs/assets/js/40.2c1f6168.js"><link rel="prefetch" href="/docs/assets/js/41.d4eb59fb.js"><link rel="prefetch" href="/docs/assets/js/42.fcc21022.js"><link rel="prefetch" href="/docs/assets/js/43.f5414e16.js"><link rel="prefetch" href="/docs/assets/js/44.2a702d17.js"><link rel="prefetch" href="/docs/assets/js/45.f7ce5c63.js"><link rel="prefetch" href="/docs/assets/js/46.a92299ec.js"><link rel="prefetch" href="/docs/assets/js/47.2ab3c263.js"><link rel="prefetch" href="/docs/assets/js/48.b00c87be.js"><link rel="prefetch" href="/docs/assets/js/49.0639790c.js"><link rel="prefetch" href="/docs/assets/js/5.01b6ed83.js"><link rel="prefetch" href="/docs/assets/js/50.6b8e6969.js"><link rel="prefetch" href="/docs/assets/js/51.1b73d6a7.js"><link rel="prefetch" href="/docs/assets/js/52.bbe46314.js"><link rel="prefetch" href="/docs/assets/js/53.0bf0e3ec.js"><link rel="prefetch" href="/docs/assets/js/54.ab731c5a.js"><link rel="prefetch" href="/docs/assets/js/55.85a552f5.js"><link rel="prefetch" href="/docs/assets/js/57.fe4e4c38.js"><link rel="prefetch" href="/docs/assets/js/58.d3ad9d7c.js"><link rel="prefetch" href="/docs/assets/js/59.df3fca62.js"><link rel="prefetch" href="/docs/assets/js/60.a077d3df.js"><link rel="prefetch" href="/docs/assets/js/61.6dd97667.js"><link rel="prefetch" href="/docs/assets/js/62.b07bbd49.js"><link rel="prefetch" href="/docs/assets/js/63.c7b27877.js"><link rel="prefetch" href="/docs/assets/js/64.70087ff8.js"><link rel="prefetch" href="/docs/assets/js/65.fd6d7a18.js"><link rel="prefetch" href="/docs/assets/js/66.10b216e6.js"><link rel="prefetch" href="/docs/assets/js/67.0f2ffe7b.js"><link rel="prefetch" href="/docs/assets/js/68.cf4a49ab.js"><link rel="prefetch" href="/docs/assets/js/69.cd07c0cc.js"><link rel="prefetch" href="/docs/assets/js/70.38a5d0a8.js"><link rel="prefetch" href="/docs/assets/js/71.7fe05b10.js"><link rel="prefetch" href="/docs/assets/js/72.3c2aa19e.js"><link rel="prefetch" href="/docs/assets/js/73.3ef6e14d.js"><link rel="prefetch" href="/docs/assets/js/74.32ba64d6.js"><link rel="prefetch" href="/docs/assets/js/75.3d7fe5e3.js"><link rel="prefetch" href="/docs/assets/js/76.3ae99780.js"><link rel="prefetch" href="/docs/assets/js/77.e567e51a.js"><link rel="prefetch" href="/docs/assets/js/78.4a9407f7.js"><link rel="prefetch" href="/docs/assets/js/79.6b27b699.js"><link rel="prefetch" href="/docs/assets/js/8.cf482f53.js"><link rel="prefetch" href="/docs/assets/js/80.699c85a6.js"><link rel="prefetch" href="/docs/assets/js/81.2de1a2ac.js"><link rel="prefetch" href="/docs/assets/js/82.3c19ef42.js"><link rel="prefetch" href="/docs/assets/js/83.bae24a9b.js"><link rel="prefetch" href="/docs/assets/js/84.89c5968d.js"><link rel="prefetch" href="/docs/assets/js/85.0b2e7c2e.js"><link rel="prefetch" href="/docs/assets/js/86.d87fb397.js"><link rel="prefetch" href="/docs/assets/js/87.dcb8e1d6.js"><link rel="prefetch" href="/docs/assets/js/88.2886e9d1.js"><link rel="prefetch" href="/docs/assets/js/89.736df243.js"><link rel="prefetch" href="/docs/assets/js/9.cbf35a82.js"><link rel="prefetch" href="/docs/assets/js/90.947afe3e.js"><link rel="prefetch" href="/docs/assets/js/91.5289166a.js"><link rel="prefetch" href="/docs/assets/js/92.7e0a6901.js"><link rel="prefetch" href="/docs/assets/js/93.67401c24.js"><link rel="prefetch" href="/docs/assets/js/94.42411128.js"><link rel="prefetch" href="/docs/assets/js/95.6b014219.js"><link rel="prefetch" href="/docs/assets/js/96.7d88cdad.js"><link rel="prefetch" href="/docs/assets/js/97.82df32a0.js"><link rel="prefetch" href="/docs/assets/js/98.c5ec3588.js"><link rel="prefetch" href="/docs/assets/js/99.0add1d70.js"><link rel="prefetch" href="/docs/assets/js/vendors~photo-swipe.c7363f24.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.e658a316.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><img src="/docs/images/mayueyue.png" alt="" class="logo"> <!----></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/docs/vue/v2/overview/" class="nav-link">
  Vue 2
</a></div><div class="nav-item"><a href="/docs/manual/" class="nav-link router-link-active">
  知识手册
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/docs/vue/v2/overview/" class="nav-link">
  Vue 2
</a></div><div class="nav-item"><a href="/docs/manual/" class="nav-link router-link-active">
  知识手册
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JavaScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/manual/javascript/" aria-current="page" class="active sidebar-link">知识概要</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#变量提升" class="sidebar-link">变量提升</a></li><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#let-和-const" class="sidebar-link">let 和 const</a></li><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#数据类型" class="sidebar-link">数据类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#类型检测" class="sidebar-link">类型检测</a></li><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#类型转换" class="sidebar-link">类型转换</a></li></ul></li><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#number" class="sidebar-link">Number</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#特殊值" class="sidebar-link">特殊值</a></li><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#数值转换" class="sidebar-link">数值转换</a></li></ul></li><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#object" class="sidebar-link">Object</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#对象描述" class="sidebar-link">对象描述</a></li><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#属性遍历" class="sidebar-link">属性遍历</a></li><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#构造函数模式" class="sidebar-link">构造函数模式</a></li><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#原型模式" class="sidebar-link">原型模式</a></li><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#原型链" class="sidebar-link">原型链</a></li><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#经典继承" class="sidebar-link">经典继承</a></li><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#组合继承" class="sidebar-link">组合继承</a></li><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#寄生式组合继承" class="sidebar-link">寄生式组合继承</a></li></ul></li><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#模块化" class="sidebar-link">模块化</a></li><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#promise" class="sidebar-link">Promise</a></li><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#iterator" class="sidebar-link">Iterator</a></li><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#generator" class="sidebar-link">Generator</a></li><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#async-await" class="sidebar-link">async / await</a></li><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#proxy" class="sidebar-link">Proxy</a></li><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#reflect" class="sidebar-link">Reflect</a></li><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#bind-call-apply" class="sidebar-link">bind,call,apply</a></li><li class="sidebar-sub-header"><a href="/docs/manual/javascript/#eventloop" class="sidebar-link">EventLoop</a></li></ul></li><li><a href="/docs/manual/javascript/ctx.html" class="sidebar-link">执行上下文</a></li><li><a href="/docs/manual/javascript/scope.html" class="sidebar-link">作用域</a></li><li><a href="/docs/manual/javascript/closure.html" class="sidebar-link">闭包</a></li><li><a href="/docs/manual/javascript/this.html" class="sidebar-link">this</a></li><li><a href="/docs/manual/javascript/promise.html" class="sidebar-link">Promise</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>浏览器</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/manual/browser/process.html" class="sidebar-link">多进程架构</a></li><li><a href="/docs/manual/browser/render.html" class="sidebar-link">渲染流程</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前后端框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/manual/framework/express.html" class="sidebar-link">Express</a></li><li><a href="/docs/manual/framework/koa.html" class="sidebar-link">Koa</a></li><li><a href="/docs/manual/framework/egg.html" class="sidebar-link">Egg</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端工程化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/manual/engineering/" class="sidebar-link">工程化</a></li><li><a href="/docs/manual/engineering/babel.html" class="sidebar-link">Babel</a></li><li><a href="/docs/manual/engineering/wp.html" class="sidebar-link">Webpack</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>网络</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/manual/networking/" class="sidebar-link">知识概要</a></li><li><a href="/docs/manual/networking/http.html" class="sidebar-link">HTTP</a></li><li><a href="/docs/manual/networking/cache.html" class="sidebar-link">HTTP 缓存</a></li><li><a href="/docs/manual/networking/dhcp.html" class="sidebar-link">DHCP</a></li><li><a href="/docs/manual/networking/icmp.html" class="sidebar-link">ICMP</a></li><li><a href="/docs/manual/networking/tcp.html" class="sidebar-link">TCP</a></li></ul></section></li><li><a href="/docs/manual/perfomance/" class="sidebar-link">性能优化</a></li><li><a href="/docs/manual/security/" class="sidebar-link">Web 安全</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="知识概要"><a href="#知识概要" class="header-anchor">#</a> 知识概要</h1> <p><div prefix="js" class="always-hidden"></div>
JS基础知识点检查列表及简要介绍。</p> <h2 id="变量提升"><a href="#变量提升" class="header-anchor">#</a> 变量提升</h2> <p>在只有<code>var</code>的年代，对于一个自定义的标识符，我们只要拆分为 <strong>声明</strong> 和 <strong>赋值</strong> 两个步骤就可以比较方便的理解变量提升了，如下</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// in foo</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'in foo'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在定义<code>a</code>的位置之前访问，没有报错，打印出来的是<code>undefined</code>，这种情况我们常解释为 <strong>声明提升，但是赋值不提升</strong>。
函数在声明的位置之前，是可以调用的，这种情况我们解释为 <strong>函数的声明和赋值都会被提升</strong>。</p> <p>从执行上下文的角度，变量提升是提升到上下文级别，提升到变量环境里面。</p> <h2 id="let-和-const"><a href="#let-和-const" class="header-anchor">#</a> let 和 const</h2> <p>在引入了<code>let</code>，<code>const</code>和块级作用域之后，“声明”这一个描述就不够具体了，如下</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught ReferenceError: Cannot access 'a' before initialization</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这里的<code>a</code>，就是 <strong>未初始化</strong>，也就是说这个东西存在，但是连默认的 undefined 初始化都没有。</p> <p>引入了 let 和 const 之后，我们可以将变量的定义，拆分成 <strong>创建</strong>，<strong>初始化</strong> 和 <strong>赋值</strong> 三个阶段。</p> <ul><li>创建：知道这个变量存在，但不允许访问</li> <li>初始化：给变量设置默认值，通常是 undefined</li> <li>赋值：表示我们的自定义初始化，第一次赋值</li></ul> <p>如果从编译的角度去看，不管是何种方式声明，在编译过程中变量都会被识别，加入到执行上下文中。比如对于 <code>let</code>，我们常说<code>TDZ</code>(暂时性死区)就意味着你要的东西存在，但是你还不能拿</p> <ul><li>TDZ，表示变量处在 <strong>已创建</strong> 但 <strong>未初始化</strong> 的阶段</li></ul> <p>可以理解为，在赋值之前，是定义了<code>getter</code>函数，访问即抛出<code>ReferenceError</code>，然后执行了初始化赋值之后，重新定义了<code>getter</code>函数允许访问。</p> <p>如果将变量提升拆分成 创建提升，初始化提升，赋值提升 三个部分，那么<code>let</code>是有提升的，它是 创建提升，但是初始化和赋值不提升。当然了，这不是我们通常意义上的变量提升。</p> <h4 id="tdz是必要的吗"><a href="#tdz是必要的吗" class="header-anchor">#</a> <code>TDZ</code>是必要的吗</h4> <p>TDZ 约定不要在自定义的初始化之前使用，是为了减少错误发生概率的策略选择而已。</p> <p>TDZ 是不是必要的呢？</p> <p>是也不是，取决你与看的角度咯。就跟喝肥宅快乐水一样，不喝快乐水喝其他的不行吗？不喝快乐水能死吗？也许不会，但是喝了会很快乐，你说喝这个快乐水是不是必要呢？</p> <h4 id="声明常量必须用-const-吗"><a href="#声明常量必须用-const-吗" class="header-anchor">#</a> 声明常量必须用 const 吗</h4> <p>是的。看你所为的”常量“是什么概念。如果说是不可修改的话，可以通过 defineProperty 设置访问器属性。
从需求实现的角度看，通过一个模块或闭包提供的变量，只要没有提供 set 方法，就可以理解为是常量，这样去理解也蛮有趣。</p> <p>但是呢，从可读性和可维护性来说，任何常量定义都应该基于 const 之上去做。</p> <p>动作上可以做到的事情(你能喝农药)，从法理的角度上是不行的(你不能喝农药)。</p> <h4 id="上下文和作用域"><a href="#上下文和作用域" class="header-anchor">#</a> 上下文和作用域</h4> <p>脱离 let 和 const 去说<code>{}</code>块级作用域，我认为是没有意义的。
对于 let 和 const，需要能够从执行上下文和作用域的角度去理解</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>从执行上下文的角度，上下文中变量的结构是怎样的呢？从作用域的角度看，两个作用域之间又是怎样联系的呢？</p> <h2 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h2> <p>简单总结为 <code>6 + 1 + BigInt</code> 共 8 种数据类型</p> <ul><li>Undefined</li> <li>Boolean</li> <li>null</li> <li>Number</li> <li>String</li> <li>Symbol</li> <li>Object</li></ul> <h3 id="类型检测"><a href="#类型检测" class="header-anchor">#</a> 类型检测</h3> <ul><li>一般够用：typeof 对于非 <code>'object'</code> 的结果是准确的</li> <li>二般额外判断：typeof 为 <code>object</code>的情况需额外判断，数组就用<code>Array.isArray</code>，<code>null</code>就直接<code>===</code>判断</li> <li>一劳永逸：Object.prototype.toString.call</li> <li>实例关系：判断实例和构造函数的关系就用 instanceof</li></ul> <p>一般而言，typeof x 是比较安全的，检查某个变量常用 typeof 判断是否定义</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// do something</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>不过由于 TDZ 的存在，不那么安全了。TDZ 表现就是 inaccessible，说好的不可访问，typeof 也是一个 RHS 呀，所以GG...。</p> <h3 id="类型转换"><a href="#类型转换" class="header-anchor">#</a> 类型转换</h3> <p>因此虽然各种转换规则很纷杂，但其实只要了解一些基本的转换，做到比较熟练即可。</p> <ul><li><p><code>+</code>作为<code>2</code>元运算符转换的两个基本规则</p> <ul><li>有字符串就转字符串</li> <li>有数字就转数字</li></ul></li> <li><p><code>+</code>作为<code>1</code>元运算符转换的基本规则</p> <ul><li>作用于非数字时，执行与<code>Number()</code>一样的转换</li></ul></li> <li><p><code>==</code>比较的基本规则，非要记就三个基本原则:</p> <ul><li>有 Number 的转 Number；</li> <li>有 Boolean 的转 Number；</li> <li>有 Object 的拆箱</li></ul></li></ul> <p>原则是尽量不使用<code>==</code>，记不住没关系，记得住也不记。
老实说，我记不住也并不想记隐式转换什么的，了解常用的显示转换即可，而对于隐式转换，应当尽量避免。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">!</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// true</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token comment">// true</span>

<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
obj <span class="token operator">==</span> <span class="token boolean">true</span> <span class="token comment">// false</span>

<span class="token operator">+</span> <span class="token string">'1'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="number"><a href="#number" class="header-anchor">#</a> Number</h2> <p>对于数字，必要了解 IEEE 754，公式如下
</p><p>
V = (-1)<sup>s</sup>*2<sup>E</sup>*M
</p>
对于 32 位和 64 位的表示结构我记为 1823 和 11152。<code>E</code>部分各bit并非完全按照数值，计算时是有偏移的。根据指数域的不同，数值可以分为规格化、非规格化、特殊值，三种情况下计算方式是不一样的。<p></p> <h3 id="特殊值"><a href="#特殊值" class="header-anchor">#</a> 特殊值</h3> <p><code>NaN</code>,<code>Infinity</code>,<code>-Infinity</code>三个特殊值，均是指数域全 1</p> <ul><li>NaN: 指数域全1，但是尾数域不全为0的数
<div class="ieee-visible" data-v-b84c2356><span class="sign" data-v-b84c2356>0</span> <span class="exp" data-v-b84c2356>11111111111</span> <span class="significand" data-v-b84c2356>------------------------非全0------------------------</span></div></li> <li>Infinity/-Infinity: 即指数域名全1，尾数域全0
<div class="ieee-visible" data-v-b84c2356><span class="sign" data-v-b84c2356>0</span> <span class="exp" data-v-b84c2356>11111111111</span> <span class="significand" data-v-b84c2356>0000000000000000000000000000000000000000000000000000</span></div></li></ul> <h4 id="number-max-safe-integer"><a href="#number-max-safe-integer" class="header-anchor">#</a> Number.MAX_SAFE_INTEGER</h4> <p>参考 <a href="https://262.ecma-international.org/6.0/#sec-number.max_safe_integer%22" target="_blank" rel="noopener noreferrer">ECMA<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 理解安全整数的概念。关键在于什么是 <strong>安全</strong>，简单可理解为能够保证 n 和 n + 1 都能准确表示，则 n 为安全整数。最大安全整数为 2^53 - 1</p> <h4 id="number-max-value"><a href="#number-max-value" class="header-anchor">#</a> Number.MAX_VALUE</h4> <p>最大值，那么自然要</p> <ul><li>指数域和尾数域都取最大值</li> <li>指数域不能全为1，否则会被当做特殊值处理</li></ul> <p>那么这个时候<code>IEEE 754</code>表示为:
<div class="ieee-visible" data-v-b84c2356><span class="sign" data-v-b84c2356>0</span> <span class="exp" data-v-b84c2356>11111111110</span> <span class="significand" data-v-b84c2356>1111111111111111111111111111111111111111111111111111</span></div></p> <p>作为一个非规格化的值，指数的计算是有偏置的，偏置计算后最大的值为1023，尾数域 52 位以及省略的一位<code>1.x</code>，加起来共<code>53</code>个<code>1</code>，那么<code>Number.MAX_VALUE.toString(2)</code>结果为<code>[1111...共53位}][00000...共971位]</code>，二进制表示字符串长度为<code>1024</code>。</p> <h4 id="number-max-value-1-infinity"><a href="#number-max-value-1-infinity" class="header-anchor">#</a> Number.MAX_VALUE + 1 !== Infinity</h4> <p>从<code>MAX_VALUE</code>和<code>Infinity</code>的<code>754</code>表示上看，MAX_VALUE的值为<code>1.1...*2^1023</code>，而<code>Infinity</code>为<code>1.0*2^1024</code>，这两个相差的不是一丁点。关键在于理解，那些大于MAX_VALUE的数，由于无法表示，都被自动转换为了 Infinity。</p> <h4 id="number-max-value-1-number-max-value"><a href="#number-max-value-1-number-max-value" class="header-anchor">#</a> Number.MAX_VALUE - 1 === Number.MAX_VALUE</h4> <p>这个问题其实与上一个问题是一类问题，在非安全整数范围内，都需要考虑<code>754</code>是否能够正确表示。<code>x - 1 === x</code>的情况，需要在安全整数范围内才符合我们的预期。<code>Number.MAX_VALUE - 1</code>在<code>754</code>中也是一个无法表示的数，最终表示就变成了<code>Number.MAX_VALUE</code>。上一个能够被表示的数如下:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Number<span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">-</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">969</span><span class="token punctuation">)</span> <span class="token operator">===</span> Number<span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
Number<span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">-</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">970</span><span class="token punctuation">)</span> <span class="token operator">===</span> Number<span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="判断-nan"><a href="#判断-nan" class="header-anchor">#</a> 判断 <code>NaN</code></h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token comment">// 方法1，IE不支持</span>
Number<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment">// false</span>
Number<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>x<span class="token operator">/</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token comment">// 方法2</span>
x <span class="token operator">=</span> <span class="token number">NaN</span><span class="token punctuation">;</span>
x <span class="token operator">!==</span> x <span class="token comment">// true</span>

<span class="token comment">// 方法3</span>
<span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'number'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNaN</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>

<span class="token comment">// 方法4</span>
Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">NaN</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="数值转换"><a href="#数值转换" class="header-anchor">#</a> 数值转换</h3> <p>主要有 parseInt, parseFloat 和 Number 三种方式</p> <h4 id="parseint"><a href="#parseint" class="header-anchor">#</a> parseInt</h4> <p>语法格式是<code>parseInt(string, radix)</code>，把握两点</p> <ul><li>始终指定第二参数<code>radix</code>，明确进制</li> <li>首字符需是指定<code>radix</code>下的合法字符，如对于<code>10</code>进制，首字符需满足<code>/^[0-9+-]/i.test(string)</code>，否则均是 NaN，因此<code>parseInt('')</code>，<code>parseInt(' ')</code>都是 NaN。</li> <li>额外说一下关于 radix &gt; 10 的情况吧，数字加字母共<code>36</code>位，因此<code>radix</code>的范围 [2,36]，对于 11 进制， <code>a</code>是合法字符，对于 12 进制，<code>a</code>和<code>b</code>是合法字符，依此类推。这些内容，知道<code>2</code>,<code>10</code>,<code>16</code>三个进制咋转换就行了，知道便知道，不知道也没什么大不了的，不需要啥都知道，更不需要死记。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 11</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 30191</span>

<span class="token comment">// Infinity 的 `I`是19进制的合法字符</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// NaN</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 18</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="parsefloat"><a href="#parsefloat" class="header-anchor">#</a> parseFloat</h4> <p>只要知道它只支持10进制就好了。parseFloat 和 Number.parseFloat 功能并没有什么不同，当然了，Number.parseFloat 用起来会让我这种强迫症更舒服一点，毕竟不喜欢用全局函数，然后就是支持性不同了。</p> <h4 id="number-2"><a href="#number-2" class="header-anchor">#</a> Number()</h4> <p>有以下核心要点</p> <ul><li>字符串转换时，如有任意非法字符则为 NaN，包括多个小数点的情况(如'1.2.3')</li> <li>对象则会执行所谓的”拆箱转换“，即调用 <code>valueOf</code> 和 <code>toString</code>，</li> <li>Number(undefined) 为 NaN</li> <li>Number(null) 为 0</li></ul> <h2 id="object"><a href="#object" class="header-anchor">#</a> Object</h2> <p>对象，继承和原型链的简单介绍。</p> <h3 id="对象描述"><a href="#对象描述" class="header-anchor">#</a> 对象描述</h3> <p>对象的属性描述符简单归纳为<code>4+2</code></p> <ul><li><p>数据属性描述符：enumerable,configurable,writable,value</p></li> <li><p>访问属性描述符：get和set
相应的有设置和获取的方法</p></li> <li><p>设置属性描述符：Object.defineProperty</p></li> <li><p>获取属性描述：Object.getOwnPropertyDescriptor, Object.getOwnPropertyDescriptors。</p></li></ul> <h3 id="属性遍历"><a href="#属性遍历" class="header-anchor">#</a> 属性遍历</h3> <p>特别指出<code>5</code>种方法，并非要死记这些方法，只是因为这里对于思考问题有代表性。从需求的角度去考虑，作为一个服务提供方，这几种方法提供了较为全面的能力，能够满足多层次的需求。如今最常用的还是<code>Object.keys</code>和<code>for in</code>，但以后其他的几个遍历方法的使用也会多起来。</p> <ul><li>self, enumerable, no symbol: Object.keys(obj)</li> <li>self, no symbol: Object.getOwnPropertyNames(obj)</li> <li>self, only symbol: Object.getOwnPropertySymbols(obj)</li> <li>self, all: Reflect.ownKeys(obj)</li> <li>self, enumerable, no symbol, with extend's: for...in</li></ul> <h3 id="构造函数模式"><a href="#构造函数模式" class="header-anchor">#</a> 构造函数模式</h3> <p>构造函数也可以称为构造对象的函数，目的就是生成对象。所谓构造函数模式，就是使用构造函数去生成对象，关键的一点是 —— <strong>所有的属性，方法，都在构造函数内部设置</strong>。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sayNmae</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'myy'</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">,</span> <span class="token string">'fe'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>构造函数的问题是很明显的，每个实例都要完全执行一遍，没有复用。</p> <p>当创建完对象之后，默认情况下可以通过 <code>person1.__proto__.constructor</code> 获得构造函数。但是<code>Person.prototype.constructor</code>这个属性可以被改写，也就是说实例和构造函数之间的关系非常弱，可能随时被切断。</p> <h3 id="原型模式"><a href="#原型模式" class="header-anchor">#</a> 原型模式</h3> <p>每个构造函数都有一个 prototype 属性指向一个对象，用以共享一些属性和方法。
构造函数的实例都将能够通过内部属性 <code>[[prototype]]</code> 访问到原型上的内容。</p> <p>原型模式，就是把共用的部分提取到 prototype 上</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayNmae</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token constant">TEST_SHARE_OBJ</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  value<span class="token operator">:</span> <span class="token number">666</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'myy'</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">,</span> <span class="token string">'fe'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'fp'</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">,</span> <span class="token string">'banzhuan'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> person2<span class="token punctuation">.</span>__proto__
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>这样就解决了构造函数模式中不必要的重复定义的问题，也提升了可用性。</p> <p>prototype 是一个共享对象，共享，就意味着同步的需要，需要注意共享的内容被修改的情况。</p> <ul><li>如果原型上的属性是一个引用类型，虽然不能重新赋值(在实例上赋值是创建一个同名属性)，但可以修改其子属性。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code>person1<span class="token punctuation">.</span><span class="token constant">TEST_SHARE_OBJ</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">2333</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span><span class="token constant">TEST_SHARE_OBJ</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2333</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span><span class="token constant">TEST_SHARE_OBJ</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2333</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这算是一个问题吗？也许并不是，但是确实需要注意。</p> <h4 id="原型相关的判断、获取和设置方法"><a href="#原型相关的判断、获取和设置方法" class="header-anchor">#</a> 原型相关的判断、获取和设置方法</h4> <ul><li>Object.getPrototypeOf/Object.setPrototypeOf</li> <li>Reflect.getPrototypeOf/Reflect.setPrototypeOf</li> <li>Person.prototype = xxxx</li> <li>Person.prototype.isPrototypeOf(person1)</li></ul> <h3 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h3> <p>如果原型是另一个类型的实例，那么最末端的实例 instance1，有 <code>[[prototype]]</code> 指向另一个实例 instance2，而 instance2 的 <code>[[prototype]]</code> 又指向一个实例...就这样地老天荒，构成一条原型链。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>￼
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>用图表示实例，原型和构造函数的关系如下
<div class="img-box" data-v-3de31b89><img src="/docs/images/js/extend.png" alt="继承" style="width:400px;height:;" data-v-3de31b89> <!----></div></p> <h4 id="原型链的问题"><a href="#原型链的问题" class="header-anchor">#</a> 原型链的问题</h4> <p>原型链的问题在于 prototype 只是某种情况下的实例</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>子类实例化时不能给父类型的构造函数传参，那么 SuperType 就不适合有自定义的内容，只适合做一些公关的方法，属性的共享。</p> <h3 id="经典继承"><a href="#经典继承" class="header-anchor">#</a> 经典继承</h3> <p>经典继承也叫”盗用构造函数“，是为了解决原型链的第一个问题 <strong>原型中包含应用值</strong>。如下方的代码所示</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>xxx <span class="token operator">=</span> <span class="token string">'xxx'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> options<span class="token punctuation">.</span>name<span class="token punctuation">,</span>
    age<span class="token operator">:</span> options<span class="token punctuation">.</span>age
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>经典继承的核心就是<code>SuperType.call(this)</code>，是在<code>SupType</code>的实例上，同时执行了<code>SupType</code>和<code>SuperType</code>的构造函数。</p> <p>经典继承的问题很明显 —— 所有内容都必须在<code>SuperType</code>执行过程中定义，<code>SuperType.prototype</code>的内容是无法继承的。</p> <h3 id="组合继承"><a href="#组合继承" class="header-anchor">#</a> 组合继承</h3> <p>组合继承，是组合什么呢？是”经典继承“和”原型继承”，既调用<code>SuperType.call(this, args)</code>来进行子类实例化，也使用<code>SupType.prototype = new SuperType()</code>设置原型进行共享。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>xxx <span class="token operator">=</span> <span class="token string">'xxx'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> options<span class="token punctuation">.</span>name<span class="token punctuation">,</span>
    age<span class="token operator">:</span> options<span class="token punctuation">.</span>age
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">SupType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="header-anchor">#</a> 寄生式组合继承</h3> <p>这个类型的继承，关键在于<code>SubType.prototype</code>是基于<code>SuperType.prototype</code>复制而来</p> <ul><li>寄生：意味着复制某个对象，然后添加一下新属性，用新对象作为<code>SupType.prototype</code></li> <li>组合：意味着盗用构造函数和原型链继承
<ul><li>盗用构造函数： 在<code>SubType</code>中调用<code>SuperType.call(this)</code></li> <li>原型链： 设置<code>SupType.prototype</code></li></ul></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>xxx <span class="token operator">=</span> <span class="token string">'xxx'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> options<span class="token punctuation">.</span>name<span class="token punctuation">,</span>
    age<span class="token operator">:</span> options<span class="token punctuation">.</span>age
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 既然已经盗用了构造函数，SubType.prototype 就没必要 new SuperType() 了</span>
<span class="token keyword">const</span> proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
proto<span class="token punctuation">.</span>constructor <span class="token operator">=</span> SubType<span class="token punctuation">;</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> proto<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="模块化"><a href="#模块化" class="header-anchor">#</a> 模块化</h2> <p>常用的模块化方案</p> <table><thead><tr><th>名称</th> <th>适用侧</th> <th>关键字</th></tr></thead> <tbody><tr><td>CommonJS</td> <td>Server(Node.js)</td> <td></td></tr> <tr><td>AMD</td> <td>Client</td> <td>define/require</td></tr> <tr><td>UMD</td> <td>Server/Client</td> <td>-</td></tr> <tr><td>ES6 Module</td> <td>Client</td> <td>export/import,export default</td></tr></tbody></table> <p>还有CMD什么的，现在主要是了解 CommonJS, UMD, ES Module 就好了。</p> <p>在早期，使用namespace，使用IIFE等来保存局部的变量，如今 ES 模块化的方案，让局部逻辑更加独立，代码结构更加清晰，实现更加统一和方便。同时结合 Webpack 等的 Tree Shaking 能力，让我们能够更灵活地组织输出内容。</p> <h4 id="webpack中的模块加载原理"><a href="#webpack中的模块加载原理" class="header-anchor">#</a> Webpack中的模块加载原理</h4> <p>JS中的内容，在 loader 转换之后，其实还是没有转换掉”import“ 或者 ”export“ 之类的内容。在 compilation 的 seal 才会对各个模块中的导入导出相关的关键字进行替换，替换为 <strong>webpack_require</strong> 相关的属性。根据模块的不同，输出的引导函数中，会定义类似于 <strong>webpack_require</strong>.r，<strong>webpack_require</strong>.n 等这样的工具函数用以获取模块，在不同类型的模块化规范间做转换。</p> <h2 id="promise"><a href="#promise" class="header-anchor">#</a> Promise</h2> <p>Promise 通过 resolve 和 reject，利用底层完善的 EventLoop 机制，降低了 executor 和 cb 的耦合度，在这个基础上又很好地设计了 then 和 catch 等实例方法去统一回调函数的组织方式。Promise 化原来嵌套形式为了链调用形式，但本质上，onFulfilled 和 onError 函数等，仍是回调函数。</p> <p>Promise 在 <a href="/docs/manual/javascript/promise.html">单独的一个文章</a> 进行了更详细的说明。</p> <h2 id="iterator"><a href="#iterator" class="header-anchor">#</a> Iterator</h2> <p>迭代器的目的是为各种不同的数据结构提供统一的访问接口，字符串，数组，Set，Map，arguments 和 NodeList 等都实现了默认的迭代器支持。在JS中，对应主要的新增语句是 for...of 循环</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> val <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 1</span>
<span class="token comment">// 2</span>
<span class="token comment">// 3</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>但是对象（Object）没有实现Iterator 接口</strong>，因为对象的遍历顺序是不确定的，可迭代对象具有无歧义的遍历顺序。（<span tiny="" class="tiny" data-v-2a0a1bb2>为什么对象的便利顺序是不确定的呢？</span>)。
可迭代对象在 Symbol.iterator 这个特殊的键上定义了迭代器工厂函数</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// Array Iterator {}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>可以在 Symbol.iterator 属性上为对象添加自定义迭代器</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">limit</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">=</span> limit<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> limit <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>limit<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> limit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token punctuation">{</span>
            done<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
            value<span class="token operator">:</span> count<span class="token operator">++</span>
          <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token punctuation">{</span>
            done<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
            value<span class="token operator">:</span> <span class="token keyword">undefined</span>
          <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>

      <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Symbol.iterator return'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>
          done<span class="token operator">:</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> counter1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Counter</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">of</span> counter1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 1</span>
<span class="token comment">// 2</span>
<span class="token comment">// Symbol.iterator return</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br></div></div><p>这个例子主要是简单介绍一下自定义迭代器的基本格式</p> <ul><li>返回对象里面有 next 和 return 方法</li> <li>return 方法会在break, continue, return 和 throw 退出循环时执行</li> <li>next 和 return 方法返回的对象称为 IteratorResult，具有 value 和 done 属性</li></ul> <h2 id="generator"><a href="#generator" class="header-anchor">#</a> Generator</h2> <p>Generator 相对于 Promise，可以说是一个更”高级“的特性，高就高在使用门槛，高很多那种高。生成器函数的基本格式如下</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">helloWorldGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">yield</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token string">'world'</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token string">'ending'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> hw <span class="token operator">=</span> <span class="token function">helloWorldGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> hw<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// function</span>
hw<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {value: &quot;hello&quot;, done: false}</span>
hw<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {value: &quot;world&quot;, done: false}</span>
hw<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {value: &quot;ending&quot;, done: true}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>生成器函数返回一个生成器对象，这个对象实现了 Iterator 接口，因此可以使用 for...of 循环和 next 方法。生成器函数应用的核心，在于理解 <strong>yield 关键字</strong> 让我们具有 <strong>暂停</strong> 和 <strong>恢复</strong> 的能力，以及 <strong>迭代器</strong> 带来的迭代能力。</p> <p>高级教程 V4 里面介绍了几种 yield 的应用（此处不搬例子）</p> <ul><li>作为可迭代对象；</li> <li>作为无穷计数器(infinity range)</li> <li>yield * 产生可迭代对象，如 yield * [1,2,3]</li> <li>yield * 产生自身，实现递归</li></ul> <p>但是虽然具有了“暂停”和“恢复”的能力，但几个例子都更像是同步代码，不过维护了一个简单的状态机而已。Generator 函数是一种异步编程解决方案，Generator 需要与异步请求联系起来，才能真正发挥作用。使用 Generator 的一个大名鼎鼎的库是 <a href="https://github.com/tj/co" target="_blank" rel="noopener noreferrer">co<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，co 允许我们像写同步代码一样去使用。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> a <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Promise { 1 }</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> co <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'co'</span><span class="token punctuation">)</span>

<span class="token function">co</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">yield</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 1</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>co 对于返回的 yield 返回的内容做了统一的判断和处理，同时结合 iterator 的状态调用 next 直到转为 done。可以看到 co 已经具备了多个Promise顺序处理的能力，可用来组织顺序接口请求。</p> <p><a href="https://eggjs.org/" target="_blank" rel="noopener noreferrer">Egg.js<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的 Controller 的实现，就是使用了 co 以支持 Generator。如下，在 Egg.js 的控制器中，进行服务端渲染的一个例子</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> Controller <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'egg'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Controller<span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token operator">*</span> <span class="token function">asyncServerRender</span><span class="token punctuation">(</span><span class="token parameter">ctx<span class="token punctuation">,</span> user</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 服务端渲染获取 html，比如 yield app.nuxt.renderRoute();</span>
  <span class="token keyword">let</span> html <span class="token operator">=</span> <span class="token keyword">yield</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'hello '</span> <span class="token operator">+</span> user<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>

  ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> html<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">HomeController</span> <span class="token keyword">extends</span> <span class="token class-name">Controller</span> <span class="token punctuation">{</span>
  <span class="token operator">*</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> ctx <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'s'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>stack<span class="token punctuation">)</span>
    <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword">yield</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">'mayueyue'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// do something ssync, such as get user data</span>
    <span class="token keyword">yield</span> <span class="token function">asyncServerRender</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> HomeController<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>在页面中输出了<code>hello mayueyue</code>，这全赖于 co 的统一处理。Egg.js 从 1.x 能够方便地升入 2.x，一个原因就在于比较独立地支持了原 Generator 的写法。</p> <h2 id="async-await"><a href="#async-await" class="header-anchor">#</a> async / await</h2> <p>这俩关键字是 ES8 的。通过 async 可以定义异步函数</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>异步函数始终返回 Promise 对象，可以看做是使用了 Promise.resolve 封装了返回值。当然，既然我们已经使用了 async/await，更多时候是不需要与 Promise 的链式写法一起用。</p> <p>与 Promise 相比，异步函数的执行就像 executor 一样会立即执行，但对错误和返回值的处理是与 promise.then 里面一样的，抛出错误会返回错误期约，而 return 会被用 resolve 封装。</p> <p>await 只能在 async 函数中使用，对于 await express 可以理解为加入到微任务队列即可，如下</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">66</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>输出顺序是 <code>1-5-66-2-3-4</code>。<code>2</code>的输出插在了<code>66</code>和<code>3</code>之间，<code>Promise.resolve(66)</code>和<code>.then</code>两个微任务并不连续，在 await 执行之后，会继续原来暂停的逻辑。按照通常认为 <code>setTimeout</code> 是一个宏任务，那么其他不管是 await 还是 resolve 都当做微任务，而<code>4</code>最后输出是符合预期的。</p> <p>async/await 可以用来模拟实现 sleep 的功能</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token parameter">duration</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve duration<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">sleepTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> label <span class="token operator">=</span> <span class="token string">'sleep'</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span>label<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">await</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span>label<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sleep: 1502.880859375 ms</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>await 能够暂停，等待 Promise 达到一个终止状态。那么 sleep 函数只要让返回的 Promise 在约定时间内达到后再 resolve 即可。</p> <p><strong>async/await 是 Generator 的一个语法糖？</strong> 我不这么认为，很多时候，我们说语法糖，其实只是因为兼容性问题，并不优雅的降级。将代码转换为了兼容性较好的另一种实现，或许底层是有相似的地方，但就像5G支持还不够，信号回退到了4G，说5G是4G的语法糖，不太合适吧。</p> <div class="custom-block tip"><p class="custom-block-title">Generator 和 async/await 对比</p> <p>async/await 可以用一句话来总结 —— 异步函数，同步执行。async/await 的一个突出特点，就是它是 ”自动同步执行“ 的，在等待的异步结束后，会继续向下执行。生成器函数返回的是一个生成器对象，其内 yield 会暂停，但不会在等待的事情完成之后自动继续。与 <a href="https://github.com/tj/co" target="_blank" rel="noopener noreferrer">co<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 就是补上了等待及继续的处理，让我们能够提取使用类似 async/await 的功能。</p></div> <h2 id="proxy"><a href="#proxy" class="header-anchor">#</a> Proxy</h2> <p>Proxy用来给对象设置一个代理对象，以添加拦截。Proxy 的使用格式如下</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">{</span>
  count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  label<span class="token operator">:</span> <span class="token string">'this is label'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span>trapTarget<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'handler override'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// handler override</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>label<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// handler override</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>像 <code>get()</code> 这样的方法，被称作<strong>捕获器(trap)</strong>，关于支持的捕获器及其参数可参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener noreferrer">MDN Proxy<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。get 捕获器拦截，相对于 Object.defineProperty 有一个很大的不同，它是对于所有属性访问生效的。如果我们只需要针对某个属性，在捕获器里面需要进行判断</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">{</span>
  count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  label<span class="token operator">:</span> <span class="token string">'this is label'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span>trapTarget<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prop <span class="token operator">===</span> <span class="token string">'label'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token string">'handler override'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> trapTarget<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>label<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// handler override</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>注意通过<code>trapTarget[prop]</code>重建了原始操作。我们使用捕获器时，不仅仅是开个关卡拦截，拦截之后往往需要对访问进行过滤和改写，都需要获得原始操作的结果。这个例子中重建原始操作的处理比较简单，但是很多情况下，这个 <strong>重建</strong> 操作，是不容易实现的。比如对于函数调用的 apply 捕获器</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">target</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">?</span> <span class="token string">'Hello '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">:</span> <span class="token string">'Hello'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">trapTarget<span class="token punctuation">,</span> thisArg<span class="token punctuation">,</span> argumentsList</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">trapTarget</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> argumentsList<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'mayueyue'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">proxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// Hello</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">proxy</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// Hello mayueyue</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>apply 参数是目标对象，被调用时的上下文对象，被调用时的参数数组。这个捕获器包含了直接调用，call, apply等多种情况，不仅仅对应 <code>Function.prototype.apply</code>，因为由于参数格式，函数调用转换为 apply 调用是比较统一的。</p> <p>额，看起来也并不复杂嘛。但是这里其实有一个问题 —— 如果 trapTarget 上本身定义了 apply 方法就出问题了。需要改变一下处理</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>trapTarget<span class="token punctuation">,</span> thisArg<span class="token punctuation">,</span> argumentsList<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><span bold="" class="bold" data-v-2a0a1bb2>真棒，又实现了一个原始操作的重建...加油，后面还有 n 多个需要去重建...</span></p> <p>我们总不能每种访问，每次使用捕获器都这样去重建吧？还有 <code>has</code>,<code>ownKeys</code>这些不那么容易重建的呢？
<span bold="" class="bold" data-v-2a0a1bb2>这样子不可行的，又苦又累繁复而无尽头，肝这些哪还有诗和远方，交给 Reflect 吧，它不需要诗和远方，软硬件设备就是它的所有。</span></p> <h2 id="reflect"><a href="#reflect" class="header-anchor">#</a> Reflect</h2> <p>Reflect 的一个作用，就是在代理对象的捕获器方法中，重建原始行为。捕获器都有对应的 Reflect(反射) API 方法，使用 Reflect 实现上一节的两个例子如下</p> <div class="language-js line-numbers-mode"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">{</span>
  count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  label<span class="token operator">:</span> <span class="token string">'this is label'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span>trapTarget<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prop <span class="token operator">===</span> <span class="token string">'label'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token string">'handler override'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>label<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// handler override</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>例子2</p> <div class="language-js line-numbers-mode"><div class="highlight-lines"><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">target</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">?</span> <span class="token string">'Hello '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">:</span> <span class="token string">'Hello'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">trapTarget<span class="token punctuation">,</span> thisArg<span class="token punctuation">,</span> argumentsList</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">Reflect</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">proxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// Hello</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">proxy</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// Hello mayueyue</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>虽然重建原始操作是 Reflect 的一个重要能力，但是，Reflect API 并不限于在捕获器中使用，反射方法可以直接用于对象的控制与操作。在 <a href="https://es6.ruanyifeng.com/#docs/reflect" target="_blank" rel="noopener noreferrer">ECMAScript 6 入门-阮一峰<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 中列举了 Reflect 的其他设计思想。我觉得比较有意思的是以下两点:</p> <ul><li>状态标记: 改变某些 Object 方法的返回结果，使其变得更加符合需要</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  value<span class="token operator">:</span> <span class="token string">'bar'</span><span class="token punctuation">,</span>
  configurable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> <span class="token string">'youtube'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>

<span class="token keyword">try</span> <span class="token punctuation">{</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> <span class="token string">'bilibili'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TypeError: Cannot redefine property: name</span>
<span class="token punctuation">}</span>

Reflect<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'youtube'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TypeError: Property description must be an object: youtube</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>Object.defineProperty 在失败时抛出错误，而 Reflect.defineProperty 操作失败时返回 false，这更便于我们判断操作结果。注意，如最后一行所示，”操作失败“不包含参数错误导致出错的情况哈，参数错误的时候还是报错的。</p> <ul><li>让 Object 的命令式操作变成函数行为</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'bar'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'name'</span> <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 1</span>
<span class="token comment">// 2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>Reflect.has 与 in 一样，都会检查 own 及原型链，我比较喜欢第二种写法，感觉更加明确。</p> <h2 id="bind-call-apply"><a href="#bind-call-apply" class="header-anchor">#</a> bind,call,apply</h2> <p>三个方法用以改变执行上下文中 this 的指向，<code>bind</code>是所谓的硬绑定，<code>call</code>接收多个参数，而<code>apply</code>接收数组参数。</p> <p>bind 和 call、apply 有本质区别</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> newFunc <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">func</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>bind 并不执行原函数，只是返回一个函数，该函数后续每次调用执行上下文中的 this 都被设置为 obj。call 和 apply 只是 func 的一次调用，只在当次执行时 this 被设置为了 obj。</p> <h2 id="eventloop"><a href="#eventloop" class="header-anchor">#</a> EventLoop</h2> <p>事件循环负责执行代码，收集和处理事件，是 JavaScript 并发的基础。
<div class="img-box" data-v-3de31b89><img src="/docs/images/js/eventloop.png" alt="eventloop" style="width:400px;height:;" data-v-3de31b89> <!----></div>
需要了解宏任务(macrotask, task)，微任务(microtask, jobs)的概念</p> <ul><li>宏任务：setTimeout，setInterval 等</li> <li>微任务：Promise，MutationObserver 等</li></ul> <p>理解事件循环，才能对异步处理有更多体会，才能理解 requestAnimateFrame, nextTick 等的原理。</p> <p><div class="reference-links" data-v-e5d351b4><p data-v-e5d351b4></p> <a href="https://youtu.be/8aGhZQkoFbQ" data-v-e5d351b4>
    What the heck is the event loop anyway?
   <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" data-v-e5d351b4>
    EventLoop processing model
   <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><a href="http://latentflip.com/loupe" data-v-e5d351b4>
    Visualizing the javascript runtime at runtime
   <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/docs/manual/javascript/ctx.html">
        执行上下文
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><div tabindex="-1" role="dialog" aria-hidden="true" class="pswp"><div class="pswp__bg"></div> <div class="pswp__scroll-wrap"><div class="pswp__container"><div class="pswp__item"></div> <div class="pswp__item"></div> <div class="pswp__item"></div></div> <div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><div class="pswp__counter"></div> <button class="pswp__button pswp__button--close"></button> <button class="pswp__button pswp__button--share"></button> <button class="pswp__button pswp__button--fs"></button> <button class="pswp__button pswp__button--zoom"></button> <div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div> <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div> <button class="pswp__button pswp__button--arrow--left"></button> <button class="pswp__button pswp__button--arrow--right"></button> <div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div></div></div>
    <script src="/docs/assets/js/app.7952ff67.js" defer></script><script src="/docs/assets/js/3.2c08a1e7.js" defer></script><script src="/docs/assets/js/56.9d9e990d.js" defer></script><script src="/docs/assets/js/10.8d48b436.js" defer></script><script src="/docs/assets/js/6.164b8275.js" defer></script><script src="/docs/assets/js/4.981889e3.js" defer></script><script src="/docs/assets/js/24.5bfcb19a.js" defer></script><script src="/docs/assets/js/14.b16e20b9.js" defer></script><script src="/docs/assets/js/7.21f341ae.js" defer></script><script src="/docs/assets/js/18.9fb89893.js" defer></script><script src="/docs/assets/js/23.60844ae4.js" defer></script>
  </body>
</html>
